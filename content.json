{"meta":{"title":"RunnningAnt·黛玛","subtitle":"Technology Never Ends","description":"web, web前端,PHP,Javascript, 乒乓球, 书法, 编程","author":"AntRunning2019","url":"https://antrunning2019.github.io/blog.github.io"},"pages":[{"title":"about","date":"2019-01-08T05:54:46.000Z","updated":"2019-01-09T02:14:15.810Z","comments":true,"path":"about/index.html","permalink":"https://antrunning2019.github.io/blog.github.io/about/index.html","excerpt":"","text":"关于我从事WEB开发，主要熟悉语言PHP，C#熟悉使用Bootstrap等主流框架;对web前端开发情有独钟;有一定的代码洁癖。 对html，css ,js,bootstript等技能有所了解。 热爱开源项目，热爱新技术，热爱新事物。 理想工作地城市：北京 关于学习正在往终身学习者前进，近期学习方向：php 关于座右铭 你工作越努力，你就越幸运。（越努力，越幸运） 关于爱好热爱乒乓球，web开发，阅读，电影（Top250），旅行，，书法。 联系我 主页：RunningAnt2019 电子邮件：pung.jia2019@gmail.com ​ pung.jia@foxmail.com GitHub：AntRunning2019 WeiBo：蹦极不栓绳1996 Twitter：luke06127845 Facebook： Luke.pung2019"}],"posts":[{"title":"Dom总结（二）节点操作","slug":"js-DOM2","date":"2019-01-11T01:00:46.000Z","updated":"2019-01-11T05:31:04.613Z","comments":true,"path":"2019/01/11/js-DOM2/","link":"","permalink":"https://antrunning2019.github.io/blog.github.io/2019/01/11/js-DOM2/","excerpt":"","text":"节点操作 两种操作： children 根据父亲找到所有的儿子 parentNode 根据儿子找到父亲更多操作： 火狐或者谷歌： 1234firstElementChild // 长子lastElementChild // 老幺previousElementSibling //同辈中的上一个nextElementSibling // 同辈中的下一个 IE6/7/8 1234firstChild // 长子lastChild //老幺previousSibling //同辈中的上一个nextSibling //同辈中的下一个 添加删除节点： createElement 添加节点，该方法只属于documen removeElement 删除节点，该方法任何父对象都可以 appendElement 追加节点，在父对象的下面追加一个节点 insertBefore 插入节点，插入到父对象下面的某个节点前面 代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;节点操作&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;ul id=&quot;ul&quot;&gt; &lt;li&gt;第一行&lt;/li&gt; &lt;li id=&quot;second&quot;&gt;第二行&lt;/li&gt; &lt;li&gt;第三行&lt;/li&gt; &lt;li&gt;第四行&lt;/li&gt;&lt;/ul&gt;&lt;div class=&quot;div&quot;&gt; &lt;div id=&quot;test&quot;&gt;test内容&lt;/div&gt;&lt;/div&gt;&lt;script&gt; /** * 两种操作： 1.children 根据父亲找到所有的儿子 * 2. parentNode 根据儿子找到父亲 * 更多操作： * 火狐或者谷歌： * firstElementChild 长子 * lastElementChild 老幺 * previousElementSibling 同辈中的上一个 * nextElementSibling 同辈中的下一个 * * IE6/7/8 * firstChild 长子 * lastChild 老幺 * previousSibling 同辈中的上一个 * nextSibling 同辈中的下一个 * 添加删除节点： * createElement 添加节点，该方法只属于document * removeElement 删除节点，该方法任何父对象都可以 * appendElement 追加节点，在父对象的下面追加一个节点 * insertBefore 插入节点，插入到父对象下面的某个节点前面 * */ var oUl = document.getElementById(&apos;ul&apos;); var oDiv = document.getElementById(&apos;test&apos;); //弹出第一个孩子的内容 alert(oUl.firstElementChild.innerHTML); //弹出最后一个孩子的内容 alert(oUl.lastElementChild.innerHTML); alert(oUl.children[0].innerHTML); //弹出父节点的类名 alert(oDiv.parentNode.className); var sUl = document.getElementById(&apos;second&apos;); // 弹出同辈的下一个元素的内容 alert(sUl.nextElementSibling.innerHTML); // 弹出同辈的上一个元素的内容 alert(sUl.previousElementSibling.innerHTML); // 创建节点li var oLi = document.createElement(&apos;li&apos;); oLi.innerHTML = &apos;赵云&apos;; // 获取到节点ul 并在里面追加节点oLi var oUl1 = document.getElementById(&apos;ul&apos;); oUl1.appendChild(oLi); // 删除节点oLi oUl1.removeChild(oLi); // 插入oLi,在sUl的前面 oUl1.insertBefore(oLi, sUl);&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"program","slug":"program","permalink":"https://antrunning2019.github.io/blog.github.io/categories/program/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://antrunning2019.github.io/blog.github.io/tags/Javascript/"},{"name":"脚本","slug":"脚本","permalink":"https://antrunning2019.github.io/blog.github.io/tags/脚本/"},{"name":"DOM操作","slug":"DOM操作","permalink":"https://antrunning2019.github.io/blog.github.io/tags/DOM操作/"}]},{"title":"Dom总结（一）","slug":"js-DOM1","date":"2019-01-10T08:00:46.000Z","updated":"2019-01-10T08:59:24.498Z","comments":true,"path":"2019/01/10/js-DOM1/","link":"","permalink":"https://antrunning2019.github.io/blog.github.io/2019/01/10/js-DOM1/","excerpt":"","text":"Dom总结DOM (Document Object Model) 译为文档对象模型，是 HTML 和 XML 文档的编程接口。 一、获取的方法 document.getElementById(); document.getElementByClassName(); 得到的是一个集合，从0开始 document.getElementByName(); document.title; //获取网页标题 document.body; // 获取body的节点，即整个DOM树 document.documentElement.clientWidth; //获得可视区域的宽度 document.documentElement.clientHeight; //获得可视区域的高度 document.getElementsByTagName(‘p’); //获取的到的是一个集合，通过访问下标依次操作 二、代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;DOM操作&lt;/title&gt; &lt;style&gt; #box &#123; width: 800px; height: 800px; margin: 0 auto; border: solid 1px black; &#125; .first &#123; width: 33%; height: 500px; border: solid 1px blue; float: left; &#125; #one &#123; width: 100%; height: 100px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"box\"&gt; &lt;div id=\"one\"&gt;1&lt;/div&gt; &lt;div class=\"first\"&gt; 2 &lt;p class=\"p1\"&gt;段落1&lt;/p&gt; &lt;p class=\"p1\"&gt;段落2&lt;/p&gt; &lt;p class=\"p1\"&gt;段落3&lt;/p&gt; &lt;/div&gt; &lt;div class=\"first\"&gt;3&lt;/div&gt; &lt;div class=\"first\"&gt;4&lt;/div&gt; &lt;input type=\"text\" id=\"txt\" placeholder=\"请输入段落内容\"&gt; &lt;input type=\"button\" value=\"改变样式\" onclick=\"change1()\"&gt; &lt;input type=\"button\" value=\"获取可视区的宽度和高度\" onclick=\"view1()\"&gt;&lt;/div&gt;&lt;script&gt; &lt;!--文档对象模型 DOM--&gt; /** * 1. 获取的方法 * document.getElementById(); * document.getElementByClassName(); 得到的是一个集合，从0开始 * document.getElementByName(); */ var tit = document.title; //获取网页标题 var bo = document.body; // 获取body的节点，即整个DOM树 var wid = document.documentElement.clientWidth; //获得可视区域的宽度 var hei = document.documentElement.clientHeight; //获得可视区域的高度 var tName = document.getElementsByTagName('p'); //获取的到的是一个集合，通过访问下标依次操作 var iDiv = document.getElementById('one'); var text1 = document.getElementById(\"txt\"); var cd = document.getElementsByClassName('first'); console.log(tit, bo, iDiv, cd, tName); function change1() &#123; tName[1].innerHTML = text1.value; &#125; function view1() &#123; alert(\"可视区的宽度为：\"+wid+\"像素\"); alert(\"可视区的高度为：\"+hei+\"像素\"); console.log(\"可视区的宽度为：\"+wid); console.log(\"可视区的高度为：\"+hei); &#125;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"program","slug":"program","permalink":"https://antrunning2019.github.io/blog.github.io/categories/program/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://antrunning2019.github.io/blog.github.io/tags/Javascript/"},{"name":"脚本","slug":"脚本","permalink":"https://antrunning2019.github.io/blog.github.io/tags/脚本/"}]},{"title":"工具推荐","slug":"软件推荐","date":"2019-01-08T05:54:46.000Z","updated":"2019-01-10T08:49:39.112Z","comments":true,"path":"2019/01/08/软件推荐/","link":"","permalink":"https://antrunning2019.github.io/blog.github.io/2019/01/08/软件推荐/","excerpt":"","text":"真正提高效率的软件：截图： Snipaste搜索： Everything （绝对是秒搜，不管文件在哪）预览： QuickLookGIF录制：GifCam任务栏透明：TransparentTB快速修改代码（任何语言的）：sublime前端开发： vscode、webstrom 、hbuider笔记： 印象笔记、XmindMd文档软件：Typora、MarkdownPad2视频播放： PotPlayer录课软件： 班迪屏录转换软件： 格式工厂","categories":[{"name":"tool","slug":"tool","permalink":"https://antrunning2019.github.io/blog.github.io/categories/tool/"}],"tags":[{"name":"工具","slug":"工具","permalink":"https://antrunning2019.github.io/blog.github.io/tags/工具/"},{"name":"高效办公","slug":"高效办公","permalink":"https://antrunning2019.github.io/blog.github.io/tags/高效办公/"}]},{"title":"C语言查漏补缺&再度深入","slug":"2018-11-26 查漏补缺&再度深入 172514","date":"2019-01-08T02:54:46.000Z","updated":"2019-01-10T08:50:51.330Z","comments":true,"path":"2019/01/08/2018-11-26 查漏补缺&再度深入 172514/","link":"","permalink":"https://antrunning2019.github.io/blog.github.io/2019/01/08/2018-11-26 查漏补缺&再度深入 172514/","excerpt":"","text":"查漏补缺&amp;再度深入 一、 字符输入输出函数–getchar/putchar getchar 函数的功能是从键盘输入一个字符，其一般形式为getchar（）； 通常把输入的字符赋予一个字符变量。 12char c;c=getchar(); putchar 函数是字符输出函数，其功能为在显示器上输出单个字符，一般形式为putchar(字符变量); 123putchar('A');putchar(x);putchr('\\n'); 例如：输入单个字符； 12345678#include &lt;stdio.h&gt;void main()&#123; char c; printf(\"输入一个字符\\n\"); c=getchar(); putchar(c);&#125; 二、分支结构总结 关系运算符和表达式 在程序中需要比较两个量的大小关系，以决定程序下一步的工作，比较两个量的运算符成为关系运算符 （一）关系运算符​ 常见的关系运算符有&lt; 、&gt;、 &lt;=、 &gt;=、 、==、 != 关系运算符都为双目运算符，结合性都为左结合，关系运算符的优先级低于算术运算符，高于赋值运算符。 在六个关系运算符中，&lt; 、&lt;=、 &gt;、 &gt;=四个的优先级相同。高于== 和！=（二）关系表达式​ 一般形式：==表达式 关系运算符 表达式== ​ 例如： a+b&gt;c-d ​ x&gt;3/2 ​ a&gt;(b&gt;c) ​ 注意：关系表达式的值是“真”“假”，用0和1表示 ​ 5&gt;0 的为真，值为1； ​ （a=3）&gt;（b=5） 因为3&lt;5，所以为假，值为零。 逻辑运算符和表达式 if语句的三种形式、嵌套 条件运算符和条件表达式（switch语句）","categories":[{"name":"program","slug":"program","permalink":"https://antrunning2019.github.io/blog.github.io/categories/program/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://antrunning2019.github.io/blog.github.io/tags/C语言/"},{"name":"编程","slug":"编程","permalink":"https://antrunning2019.github.io/blog.github.io/tags/编程/"},{"name":"函数","slug":"函数","permalink":"https://antrunning2019.github.io/blog.github.io/tags/函数/"}]},{"title":"《君主与大臣：清中期的军机处：1723-1820》","slug":"2018-12-27 《君主与大臣：清中期的军机处：1723-1820》 190345","date":"2019-01-08T02:54:46.000Z","updated":"2019-01-10T08:49:22.360Z","comments":true,"path":"2019/01/08/2018-12-27 《君主与大臣：清中期的军机处：1723-1820》 190345/","link":"","permalink":"https://antrunning2019.github.io/blog.github.io/2019/01/08/2018-12-27 《君主与大臣：清中期的军机处：1723-1820》 190345/","excerpt":"","text":"《君主与大臣：清中期的军机处：1723-1820》（美）白彬菊著，董建中译：《君主与大臣：清中期的军机处：1723-1820》，北京：中国人民大学出版社，2017年本书主要探讨的问题是： 1.军机处如何发生、何以发生， 2.其形成的原因是什么， 3.军机处为何会渐渐居于主导地位。 雍正时期的内廷: 雍正时期内廷的影响力不断增强，但始终是多个分裂的机构： 内廷制度在通信与档案录副方面有：奏折制度（1693）——外奏事处（雍正初）——内奏事处——方略馆、军机处、录副奏折（1749）； 内廷制度在议政和管理方面有：皇帝——议政王大臣会议——南书房（1677）——宗室王公——总理事务王大臣——内廷代理人（1726—1735）——军需房（1729-1735）——办理军需大臣（后来是办理军机大臣 1731-1735）——军机处（1735或1738）/内务府及侍卫； 雍正皇帝承袭了满洲人旧有的内廷议政王大臣会议，但其中充斥着储位之争中失败、心怀怨恨的集团，因而他企图创建一个高效且低调的内廷军事建议来源，以取代议政王大臣会议。此外，明朝沿袭而来的本章制度有利于外朝官僚对中央政府决策的控制，减少了皇帝决策的机会。为了赢得对外朝的优势地位，雍正皇帝尝试使用各种各样的内廷机构——总理事务王大臣、大学士、管理部务大臣、会考府——以抵消外朝运作所带来的种种问题。 雍正时期内廷的演变： 内廷心腹：怡亲王允祥、张廷玉（1723） 内廷代理人：怡亲王与张廷玉（1726 蒋廷锡1727加入） 相关机构设立：户部军需房（1729，1735解散，档案归于总理事务王大臣）、办理军需大臣（1731,1732改为办理军机大臣，1735并入总理事务王大臣）——怡亲王去世（1730）——雍正去世（1735）——内廷扩大，成为服丧期的总理事务王大臣（1735起）——王公退出总理事务王大臣，军机处出现（1738） 最早的内廷代理人可能是一并抽调作为户部堂官的人：雍正元年的怡亲王、张廷玉，雍正二年（1724）又加入一位有经验的内廷官员蒋廷锡。身为负责人，他们应该合作，讨论雍正皇帝命他们考虑的任何财政问题。因为没有时间专注于日益增多的细务，雍正皇帝不仅要求具体的建议，而且还要求有奏折摘要。表面看大多数外省官员的建议都被接受了，实际上常常是内廷代理人的看法而不是外省官员的请求最终说服了雍正皇帝 在雍正朝最后五年，存在着三个主要的内廷集团：内廷代理人、户部军需房、办理军需大臣（后来的办理军机大臣），三者同时并存。在下一朝即乾隆朝初年，这三个实体合并形成了枢密班子——军机处，之后它左右着整个中华帝国政府，直至清朝覆亡。直到雍正朝结束，雍正皇帝一直是乾纲独揽。他主要的方法之一就是保持内廷机构的软弱和非正式性。雍正皇帝因创设军机处而闻名，但我们现在知道整个雍正朝内廷保持分立，没有一个像军机处那样举足轻重的机构。两个相异的内廷机构前后使用相同的汉文名称，遮蔽了它们在组织上的截然不同。尽管一个机构的汉文用字是“军机处”，它存在于雍正朝的最后五年，但它只是数个内廷机构中的一个而已。 总理事务王大臣时期的内廷: 到了总理事务王大臣时期内廷机构急剧扩大，其职能也不断扩张，即使乾隆初的摄政期结束也没有解散，而是改头换面地存在.总理事务王大臣迅速扩大，它现在掌握着四个非正式梯队（最高梯队、辅助梯队、解散及并入总理事务王大臣的组织&lt;军需房、军机处、办理苗疆事务王大臣&gt;、皂隶），规模较雍正皇帝最初所任命的四人及他们的助手、杂役已扩大许多。在最顶端是旧有的内廷代理人梯队。这一集团由于两位亲王（庄亲王允禄、果亲王允礼）的加入已有所扩大，然而它继续由两位大学士鄂尔泰、张廷玉主导。（164）到乾隆时期，战争也不会牵扯内廷人员的全部注意力，结果，扩大了的总理事务王大臣、增多的辅助人员以及改进的文件保存制度可以用于解决新出现的问题。总理事务王大臣除了对外省请求予以议覆外，也有一些工作是满足皇帝对于信息或意见的需要；总理事务王大臣在所谓九卿议事中也起到领导作用；总理事务王大臣议事也可以协助解决某些言论悖逆案件；总理事务王大臣早期的行政业务也包括官员的任命。 在雍正时期，许多应该完全属于外朝的事务，由于它们首先秘密地上呈皇帝，也就交由内廷处理。奏折处理的事务范围在乾隆朝继续扩大。合并的内廷应付政务的能力增强，有助于它的扩张。“具题来”的指示，在乾隆及以后时期只是偶尔在奏折中能见到。现在只要合适，奏折就可以直接交外朝。奏折制度不再是皇帝、内廷圈子与外省间的一种私人通信渠道。除了一些特别指定的奏折外，现在这一制度更少秘密性，成为正式制度 乾隆时期的军机处 乾隆时期军机处人数激增。军机处有了正式的上下等第之分。地位最高的是领班军机大臣，通常是满人，汉人作为领班军机大臣在乾隆六十年中只占了八年。领班军机大臣是军机大臣是军机大臣的执行负责人，要负责大多数上谕的撰拟、携带印钥即取用军机处印信的钥匙，这些职责使他掌控内廷通信管理的许多方面。 军机处是个非正式机构，因此不存在军机处本身的人事任命；军机处所有的中高层人员都是兼职，薪俸和官品都是由本人的其他主要职务决定的。有的兼职容许军机大臣控制的六部之外的领域。许多军机大臣是翰林院的成员，如此就将他们在翰林院的一些职责带入军机处。乾隆时期，这些兼职给军机处带来了众多的职责，以前由数个外朝机构处理的许多问题都集中在了自己手上，从某些方面可以说，军机处的发展是以牺牲外朝为代价的。最终皇帝与外朝日益疏离，而对于他的内廷军机大臣则依赖有加。 嘉庆时期的军机处改革 随着嘉庆改革，以前由某些军机大臣担任、置于各部尚书之上的兼管部务被废止了。同时满洲人和蒙古人成为军机大臣的资格考查更严，嘉庆皇帝的任命不是看他军事上的英勇表现，而要有进士功名，甚至有时要求是翰林院成员。随着嘉庆皇帝亲掌大权，军机大臣的人数急速减少。再一个变化表现为给予嘉庆朝军机大臣的一些细小轻微的羞辱性处罚。 这些新的做法很难解释。它显示出军机大臣与皇帝以及其他在京官僚的关系有了变化。因为服从于常规的官僚惩处规定，军机大臣会远离皇帝而更接近外朝官僚。另一项改变军机处独特性的是准许刊印有关它的信息包括在《嘉庆会典》内，这赋予了军机处确定的政府组织的合法地位。这使得它更像一个外朝机构，同时也会提供一些保护以防止它被解散 结论摘要:1.军机处设立的时间问题 不存在单一的事件或公告可以认定作为军机处设立的时间点。因此，最好的替代方法应该是不必寻求单一的设立日期，而是确定一个设立时段。如此一来，军机处的设立可以界定为是从雍正继位到乾隆二年底（1723-1738）逐步形成的。设立时期可以分为两个阶段，第一个阶段的特点是雍正皇帝强权统治下机构的相对软弱，第二个阶段的特点是在年轻、没有经验的乾隆皇帝统治下的内廷转型. 2.内廷转型的主要阶段 第一阶段：康熙皇帝建立了地位高、人员组成有着民族特色并保持分离的几个内廷机构，雍正皇帝保留了乃父的机构分离特征 第二阶段：雍正去世后的三个月内，雍正各分离的内廷机构迅速统一。通过承袭过渡班子，即总理事务王大臣无所不包的权力得到进一步加强 第三阶段：乾隆嘉庆时期现有内廷框架内各种职能的扩张 3.18世纪有利于军机处成长的因素 保密性：内廷保密性包围和保护着军机处，并提供了一个起遮蔽作用的帷幕，使人难以看清军机处的成长。 内廷的非正式性与法外活力：对于军机处这样的内廷机构，改变则是比较简单的事情。改革通常只在内廷讨论，而且只要能说服皇帝，就可以立刻得到批准。雍正皇帝用以控制他的内廷机构的一种办法，即分隔它们，使其软弱无力，在乾隆朝及以后却作为一种法外活力协助了军机处的扩张。 兼职：兼职将业务转移到军机处，并将军机处持续的壮大伪装了起来。 通过官僚机构联系一切：军机处将有内廷经历的人置于地方职位，军机处的人脉因而遍布整个国家。 信息接触：军机处不仅能看到它自己信息丰富的文件，也可接触任何其他机构的文件。 军机处的职责：军机处所获得的大量新职责是它成长的一个标志，这反过来也促成了它的进一步发展。 通信的扩张和规范：文牍的膨胀不仅提高了军机处处理它们的能力，也帮助了军机处的崛起。 不拘于繁文缛节：奏折不用印，随手登记档较为随意。 乾隆时期的战事：战争最需要有一个高效、秘密行事的内廷班子。 到处巡幸的君主统治：军机处不得不简化自身的办事程序。 军机处满汉混合：一个强大的机构若仅由单一民族人群居主导地位，就会造成派系对立，而一个民族混合的机构则能够发展壮大而不招致对立的民族结盟的攻击。 大臣们的野心：乾隆初年大臣扩张并统一军机处的欲望。 军机大臣与皇帝的关系军机处的崛起并没有支持迄今被认为是日益增长的18世纪皇帝专制统治，而是创立了一个能够有效地运行的政府，无论北京是否有一个强大、占据优势的君主。乾隆初年的变化产生了一个私人枢密班子，随着其实力的壮大，这个班子减弱了皇帝积极干预的必要性。","categories":[{"name":"article","slug":"article","permalink":"https://antrunning2019.github.io/blog.github.io/categories/article/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://antrunning2019.github.io/blog.github.io/tags/读书笔记/"},{"name":"文献","slug":"文献","permalink":"https://antrunning2019.github.io/blog.github.io/tags/文献/"},{"name":"历史","slug":"历史","permalink":"https://antrunning2019.github.io/blog.github.io/tags/历史/"}]},{"title":"JavaScript学习笔记一","slug":"2018-11-26 JS学习 201414","date":"2019-01-06T05:54:46.000Z","updated":"2019-01-10T10:19:11.938Z","comments":true,"path":"2019/01/06/2018-11-26 JS学习 201414/","link":"","permalink":"https://antrunning2019.github.io/blog.github.io/2019/01/06/2018-11-26 JS学习 201414/","excerpt":"","text":"JavaScrip 简介一、 JavaScript历史网景公司程序员Brendan Eich 两周之内设计出JavaScript这门语言。 二、 ECMAScript ECMAScript：是一种语言标准，JavaScript诞生后微软开发了JSscript，为了让JavaScript成为全球标准，几个公司联合ECMA(European Computer Manufaturers Association)组织定制了JavaScript语言标准，被称为ECMAScript标准。 三、JavaScript的版本​ 最新版ECMAScript6标准（简称ES6），在2015年6月正式发布。 四、快速入门 Javascript代码可以直接嵌入到网页的任何一个地方，不过我们通常是把它放在标签中。 123456789&lt;html&gt;&lt;head&gt; &lt;script&gt; alert('Hello, world'); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 第二种方法：把JavaScript代码放在一个单独的.js文件中，然后HTML通过在head标签中加如下代码引入， 123456789// &lt;script src=\"\"&gt;&lt;/script&gt;&lt;html&gt;&lt;head&gt; &lt;script src=\"/static/js/abc.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; ...&lt;/body&gt;&lt;/html&gt;","categories":[{"name":"program","slug":"program","permalink":"https://antrunning2019.github.io/blog.github.io/categories/program/"}],"tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://antrunning2019.github.io/blog.github.io/tags/Javascript/"},{"name":"脚本","slug":"脚本","permalink":"https://antrunning2019.github.io/blog.github.io/tags/脚本/"}]},{"title":"《游牧者的抉择》读书笔记","slug":"2018-11-18 《游牧者的抉择》读书笔记 203540","date":"2019-01-03T05:54:46.000Z","updated":"2019-01-10T08:59:12.369Z","comments":true,"path":"2019/01/03/2018-11-18 《游牧者的抉择》读书笔记 203540/","link":"","permalink":"https://antrunning2019.github.io/blog.github.io/2019/01/03/2018-11-18 《游牧者的抉择》读书笔记 203540/","excerpt":"","text":"《游牧者的抉择》读书笔记 作者简介： 王明珂，1952年出生于台湾。台湾师范大学毕业，1992年获哈佛大学博士学位。王明珂教授从事的主要是对华夏及其边缘人群――由过去的 “戎狄蛮夷”到今日少数民族――的历史与人类学探索。 历史学家 现为台湾“中研院”历史语言研究所研究员，曾任该所人类学组主任及副所长，并曾任教于台湾大学、台湾清华大学、台湾师范大学、台湾东吴大学等校。1994至2003年间，在四川西部群山之间从事累计约一年的羌族田野研究；2002至2007年多次到内蒙古及四川西北进行蒙古族、藏族游牧经济考察。 主要著述《楚乡千古为悲歌：项羽传》（高雄：德馨室出版社，1979）。 《华夏边缘──历史记忆与族群认同》（台北：允晨文化出版公司，1997）。《华夏边缘》（简体中文修订版，北京：社科文献出版社，2006）。 《蛮子、汉人与羌族》（台北：三民书局，2001）。 《羌在汉藏之间：一个华夏边缘的历史人类学研究》（台北：联经出版事业公司，2003）。 《英雄祖先与弟兄民族》（台北：允晨文化出版公司，2006）。 《游牧者的抉择：面对汉帝国的北亚游牧部族》（台北：中央研究院、联经出版公司，2009；北京：广西师大出版社，2009）。 对“游牧民族”的四大误解：1、游牧人群逐水草而居，过着自由不拘的生活一“风吹 草低见牛羊”，是中国文人对这种无羁无東生活的浪漫写照。然而，人类学所见的游牧社会强调这是人们利用边缘、不稳定自然资源的一种经济、 社会生态体系一生活中处处充满危机与不确定，毫无浪漫可言。 2、“游牧”相对于农业面言是–种原始的人类经济生产方式，在人类文明史上:属于由“渔猎”到“农耕”的中间进化阶段。事实上，正因为游牧所利用的是边缘、不稳定的自然资源，因此它需要人们对自然(地理环境与生物)高度技术性的理解与掌握，并配合经济、社会各方面之种种精巧设计一此 远非8000年前或5000年前新石器时代的原始农民所能企及。因此在人类历史上，世界几种主要类型的专化游牧都大约出现在公元前1000年至前400年之间，远较原始农业的出现为晚。 3、似乎“游牧生活”、“游牧经济”代表一些同构型的经济生产与生活方式。事实上，游牧是人类对环境的一种精巧利用与适应，因此各种不同纬度、地形与植被环境的游牧皆有其特色。也因此，游牧的多样性是人类学游牧研究的重点之.。 4、最后也是最普遍的，人们对游牧人群有一种刻板意象，表现在西方卡通电影“花木兰”中匈奴人狰狞如野兽的造型，表现在将他们比拟为“狼”的通俗著作之中。其实，由于游牧经济及相关的社会组织特质，面对定居敌手时游牧者亦有其脆弱的一-面。 本书的主要研究对象：三种汉代中国北方游牧社会分别为: 一、正北方以草原游牧为主的匈奴(及较晚期的鲜卑); 二、西北方青海甘肃河湟地区”.以高原、高山河谷游牧为主的西羌， 三、黄土高原之东北方，以丘陵森林草原游牧为主的鲜卑、乌桓及其前身东胡。​ 游牧“游牧”,从最基本的层面来说，是人类利用农业资源匮乏之边缘环境的一种经济生产 方式。利用草食动物之食性与它们卓越的移动力，将广大地区人类无法直接消化、利用的植物资源，转换为人们的肉类、乳类等食物以及其他生活所需。然而相对于农业生产来说，这是一种单位土地产值相当低的生产方式。 游牧与其移动模式对于“游牧”人们往往只注意“牧”，而忽略其“游”的一面，或只是以“逐水草而居”来了解牧民日常生活中的经常性迁移。事实上主要便是游动、迁徙，使得“游牧”与其他各种人类经济模式中的牲畜饲养有本质上的不同。对游牧社会人群来说，“游动、 迁徙”不只是让牲畜在各种季节皆能得到适宜的环境资源，更是人们逃避各种自然与人为“风险”( 包括权力掌控与阶级剥削)以及利用更广大外在资源(如贸易与掠夺)的手段。因此“游动”深深影响游牧人群的族群认同、社会结构、领袖威权以及其社会道德与价值观。 迁移因素：气候、地形、植被、畜产、水源、等自然因素和农业、社会结构、人力配置等社会因素。 游牧社会组织：家族、氏族、部落在家庭、牧团或牧圈等人们日常接触的群体外，一个人又是一层层更大社会群体的成员。这些一层层由小而大的社会群体，经常也是人们所相信或宜称与自己有亲疏血缘关系的群体家族、 氏族、部落。“家族” 一般是指其成员血缘关系较近且可追溯的亲属群体;每个家族成员在此群体中的世代谱系位置关系都很清楚。“氏族” 是指宣称有共同祖先但血源系谱不清楚的亲属群体，因此同一家族的人只以家族称号或始祖之名来彼此凝聚。“部落” 通常指，相对于“国家”而言，社会阶序化、权力集中化程度较低的政治组织。然而在许多游牧社会中，各层次的亲属群体(家族或氏族)常有某种政治组织，或其与部落组织部分重叠。反过来说，同一“部落”的人也常认为或想象他们有共同祖先。 早期人类开始进入游牧经济的背景因素： 气候的转变（大陆度的增加，导致气候变冷） 人口增长，自然资源的匮乏（灌溉农业造成人口增加） 畜养大量的驯养动物，特别是马。 华夏族的形成：春秋时期 北方混合经济人群南下争夺农牧资源，强化了南方周王朝诸侯国上层贵族之间的. -体感一这 是华夏认同的萌芽。“华” 有众多或繁盛之意;“华夏”原与“诸夏”意义相同，都指的是-一个多元联合体。秦人在周室东迁后“驱戎”，黄河中游、下游诸国的华夏认同意识逐渐增强，并相互奥援以对抗戎狄一所 谓“内诸夏而外夷狄”。在驱戎之后，强大的华夏北方诸国更往北扩土，并建长城以维护之。此种种发展都意味着，华夏为-一保护及垄断南方农业资源的认同群体;无论是实质的长城，或是作为华夏族群边界的“非我族类”概念，皆将“戎狄”排除于华夏之外。 战国时期 北方华夏诸国对“戎狄”的征伐、驱逐及往北扩土，使得邻接华夏邦国的部分游牧或混合经济人群失了栖地，北迁至更不宜农业的地方。 秦汉帝国成立后 帝国进一 步往北方与西北方扩土。被排拒于华夏资源边界外的北方各部族，他们–方面被迫走向宜其环境的专化游牧业，一方 面尝试建构新的社会组织来适应此游牧生活，并以之抵抗华夏帝国的扩土，或以此突破帝国的资源封锁线。公元前3世纪到公元3世纪的汉代，便是北方各地游牧人群在游牧生计上、在社会组织上作种种调整与创作的时期。蒙古草原与晋陕之北的各部族，发展蒙古草原型的游牧业，并集结为游牧“国家”(匈奴)，以向其他游牧部族、绿洲城邦及长城以南的帝国争夺资源。辽西地区的各部族发展其森林草原型的专化游牧业，并组成“部落联盟”(乌桓、鲜卑等)不断往南及往西争夺农牧资源。西北方河湟的各部族则各以“ 部落”据其河谷，偶尔组成暂时性的部落联盟来对付汉帝国的人侵。 魏晋南北朝 中国历史上秦汉“华夏帝国”转变为隋唐“中原王朝”的关键时期。这个帝国性质的转变，主要是部分的匈奴、西羌、鲜卑部族迁于塞内，他们吸取华夏文化中糅合儒、法的礼仪教化与治术，配合原有的游牧部落与部落联M等组织概念，尝试建立兼治长城内外之民的政权。如此，当统一帝国再度出现时，新成立的隋唐帝国在王室血緣上、在对待长城之北游牧部族的策略上，都与秦汉帝国有相当的不同。许多历史学者早已指出隋唐帝国王室中有北族血源，唐太宗与北族结盟以安定长城南北的关系，唐帝国广开与北方草原及西域间的贸易往来，帝国内历任宰相也多有出身北方草原部族者一这些都显示唐帝国已不只是一一个由华夏建立的帝国王朝，面是一个接纳、混合各方传统的新王朝，我们可称之为“中原王朝”","categories":[{"name":"article","slug":"article","permalink":"https://antrunning2019.github.io/blog.github.io/categories/article/"}],"tags":[{"name":"读书笔记","slug":"读书笔记","permalink":"https://antrunning2019.github.io/blog.github.io/tags/读书笔记/"},{"name":"文献","slug":"文献","permalink":"https://antrunning2019.github.io/blog.github.io/tags/文献/"},{"name":"文学","slug":"文学","permalink":"https://antrunning2019.github.io/blog.github.io/tags/文学/"}]},{"title":"PHP学习笔记（听课版)","slug":"2018-11-16 PHP学习笔记（听课版） 114158","date":"2019-01-01T05:54:46.000Z","updated":"2019-01-10T08:57:40.488Z","comments":true,"path":"2019/01/01/2018-11-16 PHP学习笔记（听课版） 114158/","link":"","permalink":"https://antrunning2019.github.io/blog.github.io/2019/01/01/2018-11-16 PHP学习笔记（听课版） 114158/","excerpt":"","text":"PHP学习笔记（听课版）一、基本语句 代码段 123&lt;? php echo&apos;Hello world&apos;;?&gt; 2. echo 与print和var_dump输出的区别 123456&lt;?php echo&apos;value1&apos;,&apos;value2&apos;; print&apos;value1&apos;; var_dump(false); var_dump(&apos;hello&apos;); var_dump (array(&apos;1&apos;,&apos;2&apos;)); 12345678910111213b. php与Html的混编 ```php+HTML //指令式 &lt;?php if(true): echo &apos;hello&apos;; endif; else : echo&apos;flase&apos;; endif; // c. 注释 12345678&lt;?php/*.......多行注释.......*/$foo =&apos;hello&apos;;# 注释 3、语句 编程常见的语法 变量 顺序结构 分支结构 循环结构 函数 运算符 字面量 基础语法 变量 指令式语法 foreach 函数的作用域问题 字符串拼接 变量是编程语言中临时存放数据的容器 ​ Php中申明一个变量用的是一个美元符号$加上变量名。 ​ PHP中变量无需声明变量类型，变量的类型根据值得类型来推断。 12345678910111213141516&lt;?php //foreach //php5.4版本以后的可以如下定义数组 // 索引数组（线型数组） $arr=[1,2,3,4]; # foreach($variable as $key =&gt;$value) foreach($arr as $value)&#123; #code.... &#125; //关联数组 // $assoc =[&apos;key1&apos;=&gt;&apos;value&apos;, &apos;key2&apos;=&gt;&apos;value&apos;,&apos;key3&apos;=&gt;&apos;value&apos;] // foreach($assoc as $key =&gt;$value)&#123; #code.... &#125;","categories":[{"name":"program","slug":"program","permalink":"https://antrunning2019.github.io/blog.github.io/categories/program/"}],"tags":[{"name":"前端","slug":"前端","permalink":"https://antrunning2019.github.io/blog.github.io/tags/前端/"},{"name":"PHP","slug":"PHP","permalink":"https://antrunning2019.github.io/blog.github.io/tags/PHP/"}]},{"title":"PHP笔记2","slug":"2018-12-8 php入门2 004018","date":"2019-01-01T05:54:46.000Z","updated":"2019-01-10T08:51:28.306Z","comments":true,"path":"2019/01/01/2018-12-8 php入门2 004018/","link":"","permalink":"https://antrunning2019.github.io/blog.github.io/2019/01/01/2018-12-8 php入门2 004018/","excerpt":"","text":"运算符（operator） 是一种将数据进行运算的特殊符号，在PHP中有十种之多 赋值运算符： = $a=$b=$c=10; // 连贯复制运算 算术运算符：加、减、 乘、除、取余运算（模运算）—整数 在进行除法运算和取余运算的时候，除数不能为零。 比较运算符：比较两个数据的大小，或者是内容是否相同 大于 &gt; 小于 &lt; 大于等于 &gt;= 小于等于、 &lt;= 等于 == 左边与右边相同（大小相同） 不等于、 != 左边与右边不同（大小不同） 全等于 ===，左边与右边相同，大小以及数据类型都相同 不全等于 !== 只有大小或类型不同 12345&lt;?php //判断相等 var_dump($a==$b); //判断全等 var_dump($a===$b); 逻辑运算符 逻辑运算：针对不同的结果进行匹配 &amp;&amp; 逻辑与（左右都满足返回true ，否则返回false） || 逻辑或（左右只有一个满足即可） ！ 逻辑非（对已有条件尽心取反） 短路运算实现代码优化：（逻辑与和逻辑或）—出现概率高的放在第一位。 连接运算符连接运算符：是PHP中 1234567&lt;?php $a = 'hello'; $b =123; //将变量a和变量b连接起来 echo $a . $b; //$a.=$b-----&gt;$a =$a.$b; echo $a.=$b; 错误抑制符 在PHP中有一些错误可以提前预知，但这些错误可能无法避免，但又不希望报错给用户看，可以使用错误抑制符来处理 @ 在可能出现错误的表达式前面使用@ 12 三目运算符语法格式：表达式1？表达式二：表达式三； ​ 可以嵌套** 自操作运算符++ 自增（前置自操作、后置自操作） – 自减 如果不参与运算，++i和i++ 效果一样的，如果参与运算，就不一样（前置和后置） 衍生符号： += $ a+=$b $a=$a+$b -= $ a-=$b $a=$a-$b = $ a=$b $a=$a*$b /= $ a/=$b $a=$a/$b %= $ a%=$b $a=$a%$b 计算机码左移运算：乘2的操作 右移运输：除二操作（不完全正确），有可能出现小数 运算符的优先级 流程控制 顺序结构（代码从上往下依次执行） 分支结构( 给定一个条件，同时有多种选择执行) 循环结构 （在条件控制范围里，执行制定的代码块） 分支结构 PHP中分支结构有两种：if分支和switch分支 –如果条件特别多才会是使用的嵌套，不宜有多层– if分支适用于所有的分支结构 switch分支、有一组情形，对于一个条件，通常有多个代码执行 swicth( 条件表达式){ ​ case 值1： ​ 代码段； ​ case 值2： ​ 代码段； case 值3： ​ 代码段； case 值4： ​ 代码段； break； default： ​ //匹配失败后的代码 。。。。。。。。。； break； } 文件包含include 包含文件 includeonce 只包含一次 Require Requireonce 文件加载原理 在文件加载include或require的时候，系统会自动的将包含文件中的代码相当于嵌入当前文件中。 加载位置：在哪加载，对应的文件中的代码嵌入的位置就是对应的include位置 在PHP中被包含的文件是单独进行编译的 PHP代码执行流程： 1. 读取代码文件（PHP文件） 2. 编译，将PHP代码转换成字节码，生成opcode 3. zendengine来解析opcode，按照字节码进行了逻辑运算 4. 转换成对应的HTML代码 Include和require的区别include和includeonce的区别 ​ include系统碰到一次，执行一次；如果对一个文件多次加载，系统会多次加载。 ​ includeonce只会加载一次。 require和include的区别：包含不到文件的时候，报错的形式不一样。 include的错误级别较轻； require如果有错，后面的代码不在执行。Fatal error；没有包含的文件。 文件加载的路径问题文件加载的时候需要指定文件路径才能保证PHP正确的找到对应文件 文件加载的路径包含两大类： 绝对路径： ​ 从磁盘的根目录开始（本地绝对路径 ​ 从网站的根目录开始（网络绝对路径） ​ Windows：盘符 C：/路径/PHP文件 ​ Linux: /路径/PHP ​ 从网站根目录开始（网络绝对路径） ​ /: 相对于网站主机名对应的路径 相对路径：从当前文件目录开始的路径 ​ .| ./ 表示当前文件夹 ​ ../ 上级目录（当前文件夹的上层文件夹） 绝对路径和相对路径加载的区别： 绝对路径相对效率偏低，但是相对安全","categories":[{"name":"program","slug":"program","permalink":"https://antrunning2019.github.io/blog.github.io/categories/program/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://antrunning2019.github.io/blog.github.io/tags/PHP/"},{"name":"后端","slug":"后端","permalink":"https://antrunning2019.github.io/blog.github.io/tags/后端/"}]}]}